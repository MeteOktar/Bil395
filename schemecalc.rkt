(define env (make-hash))

(define (lookup var)
  (hash-ref env var (lambda () (error "Değişken tanımlanmamış:" var))))

(define (set-env var val)
  (hash-set! env var val)
  val)

(define (make-state input)
  (vector input 0))

(define (current state)
  (let* ((s (vector-ref state 0))
         (i (vector-ref state 1)))
    (if (< i (string-length s))
        (string-ref s i)
        #\null)))

(define (skip-whitespace state)
  (let loop ()
    (when (< (vector-ref state 1) (string-length (vector-ref state 0)))
      (when (char-whitespace? (current state))
        (vector-set! state 1 (+ (vector-ref state 1) 1))
        (loop)))))

(define (lex-match state expected)
  (skip-whitespace state)
  (let ((found (current state)))
    (if (char=? found expected)
        (vector-set! state 1 (+ (vector-ref state 1) 1))
        (error "İndekste" (vector-ref state 1)
               ": beklenen" expected "ama bulunan" found))))

(define (parse-number state)
  (skip-whitespace state)
  (let loop ((num 0))
    (let ((ch (current state)))
      (if (and (char>=? ch #\0) (char<=? ch #\9))
          (begin
            (vector-set! state 1 (+ (vector-ref state 1) 1))
            (loop (+ (* num 10) (- (char->integer ch) (char->integer #\0)))))
          num))))

(define (parse-identifier state)
  (skip-whitespace state)
  (let loop ((id ""))
    (let ((ch (current state)))
      (if (or (char-alphabetic? ch)
              (and (not (string=? id ""))
                   (or (char-numeric? ch) (char=? ch #\_))))
          (begin
            (vector-set! state 1 (+ (vector-ref state 1) 1))
            (loop (string-append id (string ch))))
          id))))

(define (parse-factor state)
  (skip-whitespace state)
  (let ((ch (current state)))
    (cond
      ((char=? ch #\()) 
       (lex-match state #\()
       (let ((val (parse-expression state)))
         (lex-match state #\))
         val))
      ((or (char-numeric? ch) (char=? ch #\+) (char=? ch #\-))
       (parse-number state))
      ((char-alphabetic? ch)
       (let ((id (parse-identifier state)))
         (lookup id)))
      (else (error "unexpected character: " ch)))))

(define (parse-term state)
  (let loop ((acc (parse-factor state)))
    (skip-whitespace state)
    (let ((ch (current state)))
      (cond
        ((char=? ch #\*)
         (lex-match state #\*)
         (loop (* acc (parse-factor state))))
        ((char=? ch #\/)
         (lex-match state #\/)
         (let ((right (parse-factor state)))
           (if (= right 0)
               (error "Division by zero")
               (loop (quotient acc right)))))
        (else acc)))))

(define (parse-expression state)
  (let loop ((acc (parse-term state)))
    (skip-whitespace state)
    (let ((ch (current state)))
      (cond
        ((char=? ch #\+)
         (lex-match state #\+)
         (loop (+ acc (parse-term state))))
        ((char=? ch #\-)
         (lex-match state #\-)
         (loop (- acc (parse-term state))))
        (else acc)))))

(define (parse-statement state)
  (skip-whitespace state)
  (if (char-alphabetic? (current state))
      (let ((start-index (vector-ref state 1)))
        (let ((id (parse-identifier state)))
          (skip-whitespace state)
          (if (char=? (current state) #\=)
              (begin
                (lex-match state #\=)
                (let ((val (parse-expression state)))
                  (set-env id val)))
              (lookup id))))
      (parse-expression state)))

(define (repl)
  (displayln "CTRL+D to exit")
  (let loop ()
    (display "input: ")
    (flush-output)
    (define line (read-line))
    (if (eof-object? line)
        (displayln "exiting")
        (begin
          (with-handlers ([exn:fail? 
                            (lambda (e)
                              (display "error: ")
                              (displayln (exn-message e))
                              (newline))])
            (let* ((state (make-state line))
                   (result (parse-statement state)))
              (display "= ")
              (displayln result)
              (newline)))
          (loop)))))

(repl)
